# Allocator notes 1: Arena Allocators

Let's introduce a basic Arena allocator to `oscars`.

The first pass of the Arena allocator was based off this [blog post][blog-post] from
GingerBill.

The primary goal of this exercise is to have a working base line to build on.


## General notes

The implementation itself does appear to function and allocate and deallocate correctly
with some caveats.

### Memory safety concerns

Currently, with the tests that are implemented, the `ArenaAllocator` does pass while
running with MIRI.

There are a couple things worth noting as far as memory safety for the current memory
safety of this implementation.

1. `ArenaAllocator` requires it's own `Box` implementation. Using the built-in box can
run into UB aronud reborrows.
2. There are open questions around double freeing when the arena's `Box` is dropped and
then the arena itself is dropped (although this could be a misunderstanding on my
(nekevss) part). 

### Room for improvement

There is actually something to be said about "what" is allocated into the Arena itself. As
it currently stands, there's no way to test this directly in Boa.

We can allocate onto the Arena's heap. We could create a control plane to manage
multiple `ArenaAllocators` to handle any overflow. However, we have no way to reasonably
determine when the Arena should be dropped.

Why? Well we have no way to know if a value has been "dropped" or not. So this points to
two things.

1. We need to somehow manage a way to visit those allocated blocks in our arena to check on
whether they are alive or dead.
2. We need a header on the allocated block that marks whether that block is alive or dead.

With these two features implemented, we would then be able to determine whether an Arena
contained no live blocks of memory and could then be dropped.

### Potential use case

This current allocator may be perfect for a GC that never runs a collection phase, and simply
grows the heap and drops the heap at the end of the program.

## Conclusion

Arena allocators may very well be a valid path forward, but it will be dependent on the
intrinsics around the arena allocator or the GC policy itself (i.e., do we want a GC that
never collects).

The intrinsics that we will need to be concerned about is the header for the allocated
block of memory, and the manner in which an Arena manages itself.

[blog-post]: https://www.gingerbill.org/article/2019/02/08/memory-allocation-strategies-002/ 
