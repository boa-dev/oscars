# Mempool Alloc Take 2

Now that we've looked at an Arena based allocator.

Let's take the same approach for a mempool.

This attempt will still be using GingerBill's blog post on [Pool allocators][blog-post]

## Pre implementation thoughts

Based on the reading, there is some interesting potential in this approach. We potentially
have the ability to track whether their are any live chunks and free chunks.

## Implementation notes

### Chunk size limitation

Chunks in this implemention have a min chunk size. This is because we are assigning
a pointer to the first `size_of::<usize>()` bytes in a chunk. So the minimum chunk
size MUST be at minimum `size_of::<usize>()`. Or we would exceed the allowable value.

So the question remains about whether that still makes this a usable model. Is there a
way that we can lower the minimum chunk size?

We could potentially store the offset in a `u8` or `u16`, but that is a little concerning
because it restricts are upper bound of chunks ... maybe something to try in the future.
For right now, this seems like a fair enough tradeoff as most GC types will probably be
above `size_of::<usize>()`.

### Potential optimization: Pool<T>

This is implementation is meant to focux on allocating erased values. That is, it will
take any value `T` as long as the size and the alignment are the same.

A different approach might be to restrict a pool to be generic over `T`. Then data of
similar types are always restricted to the same pool.

There may be down sides to this approach if the pool requests data but only one `T` is
ever allocated. That seems like it could be inefficient.

## Conclusion

Performance not withstanding, this allocator appears to have the best general approach
assuming most objects are of the same size in a program.

We have the ability to "deallocate" individual chunks to reclaim some memory overall. The
primary concern about allocating pages for a specific size is that it may be inefficient
and we end up allocating more memory than intended that never ends up used.

[blog-post]: https://www.gingerbill.org/article/2019/02/16/memory-allocation-strategies-004/
