## Exploring `Collector: Allocator` possibilities (note 1/n)

Note author: shruti2522

Issue #11 brought up making `Collector` a supertrait of `Allocator` from `allocator_api2`. The idea is to use `Vec<T, &MyCollector>` directly, backed by the gc arena, without extra handle types

It seems possible. But actually running it hits some Rust ownership walls. Here's what I've run into so far. I'm still wrapping my head around some of this, so the fixes are mostly just ideas at this point

### 1. `&self` vs `&mut self`

**What I'm seeing:**
`Allocator` needs `&self` to allocate, but our `collect()` needs `&mut self`. If we make a `Vec<u64, &MarkSweepGarbageCollector>`, we've borrowed the gc. If we then try to call `gc.collect()`, the borrow checker yells because we can't have a mutable borrow while the vec holds a shared one.

**Potential ways around it:**
- Just cast pointers to bypass the check. This works in testing, but it feels risky because we'd have to manually guarantee `collect` never frees the Vec's page.
- Maybe we change `collect(&mut self)` to `collect(&self)` and put the internal state in `RefCell` or `UnsafeCell`? This might be a cleaner solution, but it needs more thought

### 2. Reentrancy issues

**What I'm seeing:**
If we try the interior mutability route, the arena is in a `RefCell`. `allocate()` would call `borrow_mut()` on it. If an allocation triggers `collect()` internally, it might try to borrow the arena again. A double `borrow_mut()` equals a runtime panic.

**Potential ways around it:**
- Use `UnsafeCell` to skip runtime tracking, but that could be dangerous.
- decouple allocation from collection: Maybe `allocate()` should never trigger a gc cycle? It could just ask for memory, and we could have something else watch the threshold to trigger `collect()` sequentially, this seems safer

### 3. `deallocate` does nothing

**What I'm seeing:**
Our arena is a bump allocator, which doesn't give memory back slot by slot. `deallocate` has nowhere to put the memory, so a shrinking Vec might just leak its old buffer until the whole arena drops.

**Potential ways around it:**
- Maybe this is fine? standard bump allocators work this way
- If we want to be clean, we could make an `ArenaHeapItem::RawBytes` variant so `allocate()` returns a proper chunk that can be reclaimed during the sweep phase. I'm not sure if it's worth the overhead yet.

### 4. Trace integration

**What I'm seeing:**
The mark phase doesn't know what's in a `Vec<T, &Collector>`. If there's a `Gc<U>` inside, the gc won't see it and might accidentally sweep it.

**Potential ways around it:**
- Maybe use a GC aware wrapper like `GcVec<T>` that implements `Trace`? It could register itself with the gc root queue on creation

### Early thoughts

`Collector: Allocator` seems possible, but it looks like we'd need to shift the collector entirely to `&self` with interior mutability and rework how allocation thresholds happen.