# WeakMap Support

Note author: shruti2522

This document summarizes all the changes made to add weak map support to the mark sweep collector.

This adds `WeakMap<K, V>` to the mark sweep collector backed by ephemerons.
Each entry's key is held weakly and when the key is collected, the entry is pruned from the map automatically.

## changes made in PR #13

### `WeakGcBox` refactor

Previously `WeakGcBox<T>` allocated its own `GcBox<T>` and used an `IS_WEAK`
bit in the header flags to mark it as weak. this approach made sense as a first pass but a weak reference to an existing `Gc<K>` should point at the same allocation, not create a second one.
The GC would never see the key as dead if `WeakGcBox` held its own copy.

So I refactored `WeakGcBox` to hold an `ErasedArenaPointer` into an existing
allocation, also removed `IS_WEAK` flag, `weak_white`/`weak_black` header constructors
and the related `GcBox` code from `gc_header.rs` and `gc_box.rs`

### `Ephemeron::new_in` now uses `WeakGcBox<K>`

`Ephemeron::new_in` used to accept a value `K` and create a `WeakGcBox`
internally. Now it takes a `WeakGcBox<K>` directly. The caller creates the weak
reference from an existing `Gc<K>`. This keeps things organized by
separating how we create the weak link from how the ephemeron uses it

### new cleanup functions added to `EphemeronVTable`

Added `is_reachable_fn` and `finalize_fn` to `EphemeronVTable`. This
lets the collector's sweep phase check if a key is still alive and run any
finalizers without needing to know the specific types involved.

### `WeakMap<K, V>`

It's a `HashMap<usize, ArenaPointer<Ephemeron<K, V>>>`,
keyed by the raw pointer address of `Gc<K>`. This gives O(1) average time
for insert, lookup and remove

- `insert` removes any existing entry for the key before allocating a new ephemeron.
This prevents the old one from leaking into the collector queue when a value is
updated

- `remove` takes the entry out of the map but the backing ephemeron stays in the
collector queue, it gets swept when the key is collected.

`prune_dead_entries` only visits entries still in `self.entries` so there is no
risk of reading freed memory.

- `Trace` is handled, the ephemerons are in the collector's own queue so `WeakMap` itself doesn't need to do anything extra

## how the collector owns the map

`WeakMap::new(collector)` boxes the `WeakMapInner<K, V>`, grabs a raw pointer
from the box before erasing it to `Box<dyn ErasedWeakMap>`, then pushes that
erased box into `collector.weak_maps`. The `WeakMap` handle just holds that raw
pointer and is valid for as long as the collector lives

`ErasedWeakMap` is an internal helper with one method: `prune_dead_entries`.
during `collect()` the collector calls it on every map in `weak_maps` after the
sweep phase but before the dead arenas are freed. this ensures we can still read
the dropped flag on ephemerons before their memory is gone.

In my fisrt attempt, I made users manually register their maps with the collector, this
was awkward because it required `unsafe` code. It was also hard for the collector to safely
keep track of maps that lived outside its own memory. Worse, if a user forgot to
unregister a map before deleting it, the collector was left holding a bad pointer
which could cause the whole program to crash

By allocating `WeakMapInner` on the collector's heap and giving the collector ownership,
we eliminated the manual registration step completely. the user gets a handle that
is valid for the collector's lifetime, the aliasing
concerns are resolved because the collector owns the memory it prunes

## potential improvements

**`weak_map.rs`**

- explore using `HashTable` instead of `HashMap` to save memory.
- consider whether `insert` should take an `Ephemeron` directly instead of a key/value pair.

## conclusion

This approach gives us a map that cleans itself up automatically. It lives exactly
as long as the collector does, users don't have to fiddle with manual registration
or write `unsafe` code, and it plugs right into the collector's existing trace
and sweep phases.

In the future, the best improvement would be switching from `HashMap` to `HashTable`
to save memory. Until then, this first version works well and gives us the weak map behavior we need
